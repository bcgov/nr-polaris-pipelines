@Library('polaris')
import ca.bc.gov.nrids.polaris.BrokerIntention
import ca.bc.gov.nrids.polaris.JenkinsUtil
import ca.bc.gov.nrids.polaris.Podman
import ca.bc.gov.nrids.polaris.Vault

def env_short = JenkinsUtil.convertLongEnvToShort("${params.envLong}")
def intention
def podman
// Exit codes: 0=no anomalies, 20=anomalies found, 99=error
// Make this configurable for reusability with other scan containers
def SCAN_EXIT_CODE_SUCCESS = 0
def SCAN_EXIT_CODE_ANOMALIES = 20
def SCAN_EXIT_CODE_ERROR = 99

pipeline {
    agent {
        label Podman.AGENT_LABEL_APP
    }
    environment {
        PROJECT = "${params.project}"
        COMPONENT = "${params.component}"
        GITHUB_OWNER = "${params.githubOwner}"
        GITHUB_REPO = "${params.githubRepo}"
        GITHUB_TAG = "${params.githubTag}"
        CONTAINER_IMAGE = "${params.containerImage}"
        TARGET_ENV_LONG = "${params.envLong}"
        TARGET_ENV_SHORT = "${env_short}"
        TMP_VOLUME = "data-scan.${UUID.randomUUID().toString()[0..7]}"
        SCHEDULED_DATA_SCAN_USER_ID = "${params.scheduledDataScanUserId}"
        EVENT_PROVIDER = "${params.eventProvider}"
        PODMAN_REGISTRY = "docker.io"
        CONTAINER_IMAGE_CONSUL_TEMPLATE = "hashicorp/consul-template:0.41.3"
        PODMAN_USER = "wwwadm"
        NR_DATABASE_MIGRATION_ROLE_ID = credentials('knox-nr-database-migration-tools-role-id')
        NR_BROKER_TOKEN = credentials('nr-broker-jwt')
        DB_ROLE_ID = credentials("knox-${params.project}-${params.component}-${env_short}-role-id")
        AUTHFILE = "auth.json"
        NOTIFICATION_RECIPIENTS = "${params.notificationRecipients}"
    }
    stages {
        stage('Banner') {
            steps {
	            script {
                    echo "==================="
                    echo "NR Polaris Pipeline"
                    echo "==================="
                    echo ""
                    echo "Data scan pipeline"
                    echo ""
                    echo "Jenkinsfile: https://github.com/bcgov-nr/polaris-pipelines/blob/main/pipelines/database-scan/Jenkinsfile"
                }
            }
        }
        stage('Setup') {
            steps {
                script {
                    // Validate required parameters
                    if (!env.GITHUB_TAG || env.GITHUB_TAG.trim().isEmpty()) {
                        error("GITHUB_TAG parameter is required. Provide a Git tag to deploy (e.g., v1.2.3)")
                    }
                    // Set the build display name
                    currentBuild.displayName = "#${BUILD_NUMBER} - ${params.githubTag} - ${params.envLong}"
                    env.CAUSE_USER_ID = """${env.SCHEDULED_DATA_SCAN_USER_ID ? env.SCHEDULED_DATA_SCAN_USER_ID :
                        JenkinsUtil.getCauseUserId(currentBuild)}"""
                    env.CURRENT_DIR = sh(
                        returnStdout: true,
                        script: 'pwd'
                    ).trim()
                }
                sh "mkdir -p ${env.TMP_VOLUME} && chmod 775 ${env.TMP_VOLUME}"
                echo "Current directory: ${CURRENT_DIR}"
                echo "Temporary volume: ${TMP_VOLUME}"
                echo "GitHub tag: ${GITHUB_TAG}"
            }
        }
        stage('Scan for anomalies') {
            steps {
                script {
                    // open intention to get registry and db creds
                    intention = new BrokerIntention(env.NR_BROKER_TOKEN, readJSON(file: 'scripts/intention-database-transient.json'))
                    intention.setEventDetails(
                        userName: env.CAUSE_USER_ID,
                        provider: env.EVENT_PROVIDER,
                        url: env.BUILD_URL,
                        serviceName: env.COMPONENT,
                        serviceProject: env.PROJECT,
                        environment: env.TARGET_ENV_LONG
                    )
                    intention.open()
                    intention.startAction("login")
                    def vaultToken = intention.provisionToken("login", env.NR_DATABASE_MIGRATION_ROLE_ID)
                    def vault = new Vault(vaultToken)
                    def registryCreds = vault.read('apps/data/tools/db-pipeline/nr-database-migration/artifactory')
                    env.REGISTRY_USERNAME = registryCreds['sa_username']
                    env.REGISTRY_PASSWORD = registryCreds['sa_password']
                    env.VAULT_TOKEN = intention.provisionToken("database", env.DB_ROLE_ID)
                    intention.startAction("database")
                    podman = new Podman(this, null, env.AUTHFILE, "artifacts.developer.gov.bc.ca/cc20-gen-docker-local")
                    podman.login(authfile: "${env.TMP_VOLUME}/${env.AUTHFILE}", options: "-u ${env.REGISTRY_USERNAME} -p ${env.REGISTRY_PASSWORD}")
                    // Capture both output and exit code, masking VAULT_TOKEN
                    def scanResult
                    wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [[var: 'VAULT_TOKEN', password: env.VAULT_TOKEN]]]) {
                        scanResult = sh(
                            returnStdout: true,
                            script: """
                                set +e
                                OUTPUT=\$(podman run --rm --authfile=${env.TMP_VOLUME}/${env.AUTHFILE} --security-opt label=disable --userns keep-id \
                                    -e VAULT_TOKEN=${env.VAULT_TOKEN} \
                                    -e APP_ENV=${env.TARGET_ENV_SHORT} \
                                    artifacts.developer.gov.bc.ca/cc20-gen-docker-local/${env.CONTAINER_IMAGE}:${env.GITHUB_TAG} \
                                    --env ${env.TARGET_ENV_SHORT} --row-count-only)
                                EXIT_CODE=\$?
                                echo "\${OUTPUT}"
                                echo "EXIT_CODE=\${EXIT_CODE}"
                            """
                        ).trim()
                    }

                    // Parse output and exit code
                    def lines = scanResult.split('\n')
                    def exitCodeLine = lines.find { it.startsWith('EXIT_CODE=') }
                    def exitCode = exitCodeLine ? exitCodeLine.replace('EXIT_CODE=', '').toInteger() : -1
                    env.rowCountOutput = lines.findAll { !it.startsWith('EXIT_CODE=') }.join('\n').trim()
                    env.exitCode = exitCode.toString()

                    echo "Anomaly row count: ${env.rowCountOutput}"
                    echo "Container exit code: ${exitCode}"

                    // Validate exit code
                    if (exitCode == SCAN_EXIT_CODE_SUCCESS || exitCode == SCAN_EXIT_CODE_ANOMALIES) {
                        echo "✓ Scan completed successfully (exit code ${exitCode})"
                    } else if (exitCode == SCAN_EXIT_CODE_ERROR) {
                        error("Scan failed with error exit code ${exitCode}")
                    } else {
                        error("Scan failed with unexpected exit code ${exitCode}")
                    }
                    intention.endAction("database")
                }
            }
        }
        stage('Display anomaly results') {
            when { expression { env.exitCode?.toInteger() == SCAN_EXIT_CODE_ANOMALIES } }
            steps {
                script {
                    // Display results and validate exit code (mask VAULT_TOKEN)
                    def displayExitCode
                    wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [[var: 'VAULT_TOKEN', password: env.VAULT_TOKEN]]]) {
                        displayExitCode = sh(
                            returnStatus: true,
                            script: """
                                podman run --rm --authfile=${env.TMP_VOLUME}/${env.AUTHFILE} --security-opt label=disable --userns keep-id \
                                    -e VAULT_TOKEN=${env.VAULT_TOKEN} \
                                    -e APP_ENV=${env.TARGET_ENV_SHORT} \
                                    artifacts.developer.gov.bc.ca/cc20-gen-docker-local/${env.CONTAINER_IMAGE}:${env.GITHUB_TAG} \
                                    --env ${env.TARGET_ENV_SHORT}
                            """
                        )
                    }

                    echo "Display results exit code: ${displayExitCode}"

                    // Validate exit code
                    if (displayExitCode == SCAN_EXIT_CODE_SUCCESS || displayExitCode == SCAN_EXIT_CODE_ANOMALIES) {
                        echo "✓ Results displayed successfully (exit code ${displayExitCode})"
                    } else if (displayExitCode == SCAN_EXIT_CODE_ERROR) {
                        error("Display failed with error exit code ${displayExitCode}")
                    } else {
                        error("Display failed with unexpected exit code ${displayExitCode}")
                    }

                    // Send email notification about detected anomalies
                    env.ANOMOLIES_MESSAGE = "Data scan detected ${env.rowCountOutput} anomalies in ${env.COMPONENT} (${env.TARGET_ENV_LONG})"
                    sh """
                        printf "\${BUILD_URL}\\n\\n\${ANOMOLIES_MESSAGE}" | mailx -s "Data quality issue detected" "${env.NOTIFICATION_RECIPIENTS}"
                    """
                    echo "✓ Email notification sent to ${env.NOTIFICATION_RECIPIENTS}"
                }
            }
        }
        stage('Podman logout') {
            steps {
                script {
                    intention.endAction("database")
                    podman.logout(authfile: "${env.TMP_VOLUME}/${env.AUTHFILE}")
                }
            }
        }
    }
    post {
        success {
            script {
                if (intention) {
                    println intention.close(true)
                }
            }
        }
        unstable {
            script {
                if (intention) {
                    println intention.close(false)
                }
            }
        }
        failure {
            script {
                if (intention) {
                    println intention.close(false)
                }
                // Send email notification about pipeline failure
                env.FAILURE_MESSAGE = "Data scan pipeline failed for ${env.COMPONENT} (${env.TARGET_ENV_LONG})"
                sh """
                    printf "\${BUILD_URL}\\n\\n\${FAILURE_MESSAGE}" | mailx -s "Data scan pipeline failed" "${env.NOTIFICATION_RECIPIENTS}"
                """
                echo "✓ Failure notification sent to ${env.NOTIFICATION_RECIPIENTS}"
            }
        }
        aborted {
            script {
                if (intention) {
                    println intention.close(false)
                }
            }
        }
        always {
            cleanWs(
                cleanWhenAborted: true,
                cleanWhenFailure: false,
                cleanWhenSuccess: true,
                cleanWhenUnstable: false,
                deleteDirs: true
            )
            script {
                if (env.TMP_VOLUME.startsWith('data-scan.')) {
                    echo "Delete temporary directory: ${env.TMP_VOLUME}"
                    sh "rm --preserve-root -rf '${env.CURRENT_DIR}/${env.TMP_VOLUME}'"
                } else {
                    echo "Skipping deletion of temporary directory: ${env.TMP_VOLUME}"
                }
            }
        }
    }
}
