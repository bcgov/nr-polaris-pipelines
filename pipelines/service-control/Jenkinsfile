@Library('polaris@feat/stages')
import ca.bc.gov.nrids.polaris.BrokerApi
import ca.bc.gov.nrids.polaris.BrokerIntention
import ca.bc.gov.nrids.polaris.JenkinsPipeline
import ca.bc.gov.nrids.polaris.JenkinsUtil
import ca.bc.gov.nrids.polaris.Podman
import ca.bc.gov.nrids.polaris.Vault

import groovy.json.JsonOutput

def intention
def jp = new JenkinsPipeline(this)
def serviceCatInfo
def appBaseDir = "\$(pwd)/app"
def ansibleBaseDir = "\$(pwd)/ansible"
def playbookBaseDir
def podman = new Podman(this, "\$(pwd)/auth.json")
// Params
// params.gitRepo
// params.gitBasicAuth
// params.gitTag
// params.brokerJwt
// params.user
// params.service
// params.environment
// params.controlAction

pipeline {
    agent {
        label Podman.AGENT_LABEL_APP
    }

    stages {
        stage('Initialize') {
            steps {
                script {
                    // Set the build display name
                    currentBuild.displayName = "#${BUILD_NUMBER} - ${params.environment ?: 'unknown-env'}: ${params.controlAction ?: 'no-action'}"
                }
            }
        }
        stage('Banner') {
            steps {
                echo """
                ====================================================
                -                NR Polaris Pipeline               -
                ====================================================

                Job:    ${env.JOB_NAME}
                Build:  #${env.BUILD_NUMBER}
                URL:    ${env.BUILD_URL}

                Service control pipeline

                Jenkinsfile:
                https://github.com/bcgov-nr/polaris-pipelines/blob/main/pipelines/service-control/Jenkinsfile

                Ansible Polaris collection:
                https://github.com/bcgov/nr-polaris-collection

                Developers are expected to review the documentation
                of all roles used by their Ansible playbook file.
                ====================================================
                """.replaceAll("(?m)^[ \t]+", "")
                // Ensure clean workspace before starting
                cleanWs(
                    deleteDirs: true,
                    patterns: [
                        [pattern: "${appBaseDir}", type: 'INCLUDE'],
                        [pattern: "${appBaseDir}@tmp", type: 'INCLUDE'],
                        [pattern: "infra", type: 'INCLUDE'],
                        [pattern: "infra@tmp", type: 'INCLUDE']
                    ]
                )
                echo appBaseDir
                echo ansibleBaseDir
                sh 'ls -al'
            }
        }
        stage('Checkout service') {
            steps {
                script {
                    dir(appBaseDir) {
                        def catalogs = jp.retrieveRepoCatalogs(
                            params.gitRepo,
                            params.gitBasicAuth,
                            params.gitTag);

                        serviceCatInfo = jp.findServiceInCatalogs(catalogs, params.service);
                        if (serviceCatInfo == null) {
                            error "Service '${params.service}' not found in catalog(s) of repo '${params.gitRepo}'"
                        }
                        echo "Found service '${params.service}' in catalog: ${serviceCatInfo.path}"
                        playbookBaseDir = jp.retrieveServicePlaybooks(serviceCatInfo)
                    }
                    def brokerApi = new BrokerApi("${params.brokerJwt}")
                    def serviceIds = brokerApi.doUniqueKeyCheck('service', 'name', params.service)
                    echo serviceIds.join('\n')
                    if (serviceIds.size() == 0) {
                        error "Service '${params.service}' not found in broker"
                    } else if (serviceIds.size() > 1) {
                        error "Multiple services named '${params.service}' found in broker: ${serviceIds.join(', ')}"
                    }
                    def service = brokerApi.getCollectionById('service', serviceIds[0])
                    echo "Found service in broker: ${service}"
                }
            }
        }
        stage('Retrieve inventory') {
            steps {
                dir(playbookBaseDir) {
                    script {
                        jp.retrieveAnsibleInventory()
                        sh 'ls -al'
                    }
                    echo "Retrieve inventory for service '${params.service}' in environment '${params.environment}'"
                }
            }
        }
        stage('Open Intention') {
            steps {
                script {
                    def projectName = serviceCatInfo.catalog.metadata.name
                    intention = new BrokerIntention("${params.brokerJwt}", readJSON(file: "pipelines/service-control/service-control-intention.json"))
                    echo "${params.environment}"
                    intention.setEventDetails(
                        userName: params.user.toString(),
                        url: env.BUILD_URL,
                        provider: "Jenkins Service Control",
                        serviceName: params.service.toString(),
                        serviceProject: projectName,
                        environment: params.environment.toString()
                    )
                    // if (params.controlAction == "start") {
                    //     intention.filterActionsByIds(['login', 'start'])
                    // } else if (params.controlAction == "stop") {
                    //     intention.filterActionsByIds(['login', 'stop'])
                    // }
                    echo "${intention.intention.actions[0].service.environment}"

                    intention.open()
                    intention.openResponse.actions.each { key, value ->
                        env."ACTION_TOKEN_${key.toUpperCase()}" = "${value.token}"
                    }
                }
            }
        }
        stage('Login and prepare') {
            steps {
                script {
                    intention.startAction("login")

                    def vaultToken = intention.provisionToken("login", credentials('knox-jenkins-jenkins-apps-prod-role-id'))
                    def vault = new Vault(vaultToken)
                    vault.readToObject("apps/data/prod/jenkins/jenkins-apps/artifactory", env)
                    vault.readToObject("apps/data/prod/jenkins/jenkins-apps/cdua", env)
                    vault.revokeToken()

                    podman.login(options: "-u ${env.REGISTRY_USERNAME} -p ${env.REGISTRY_PASSWORD}")
                }
            }
        }
        stage('Retrieve collection') {
            steps {
                dir(ansibleBaseDir) {
                    echo "Retrieve collection"
                    script {
                        def version = "${params.ansibleCollectionBranchTag != null && params.ansibleCollectionBranchTag != "" ? ",${params.ansibleCollectionBranchTag}" : ",v3.5.0"}"
                        def url = "git+https://github.com/bcgov/nr-polaris-collection.git#polaris/deploy${version}"
                        def path = './collections/ansible_collections'

                        jp.retrieveAnsibleCollection(podman, url, path)
                        sh 'ls -al'
                    }
                }
            }
        }

// Params
// params.gitRepo
// params.gitBasicAuth
// params.gitTag
// params.brokerJwt
// params.user
// params.service
// params.environment
// params.controlAction

        stage('Run service control') {
            environment {
                // GITHUB_RUNID= "${params.githubRunId}"
                // TRIGGER_URL = "${params.triggerUrl}"
                // HTTP_PROXY = "${params.environment == 'production' ? 'http://forwardproxy.nrs.bcgov:23128' : 'http://test-forwardproxy.nrs.bcgov:23128'}"
                PODMAN_SOURCE_ROOT = "${params.sourceRoot != null && params.sourceRoot != "" ? params.sourceRoot : "."}"
                PODMAN_PLAYBOOKS_PATH = "${params.playbooksPath != null && params.playbooksPath != "" ? params.playbooksPath : "playbooks"}"
            }
            steps {
                script {
                    dir(playbookBaseDir) {
                        try {
                            echo "Modify ${params.environment} environment"
                            env.ENV_SHORT = JenkinsUtil.convertLongEnvToShort("${params.envLong}")
                            if (env.ENV_SHORT == 'dev') {
                                env.PODMAN_ANSIBLE_INVENTORY_PATH = 'smtdlvr'
                            } else if (env.ENV_SHORT == 'test') {
                                env.PODMAN_ANSIBLE_INVENTORY_PATH = 'smttest'
                            } else if (env.ENV_SHORT == 'prod') {
                                env.PODMAN_ANSIBLE_INVENTORY_PATH = 'prod'
                            }
                            podman.run("willhallonline/ansible:2.16-alpine-3.21",
                                options: "-v \$(pwd)/collections:/ansible/app/playbooks/collections \
                                    -v \$(pwd)/app:/ansible/app \
                                    -v \$(pwd)/infra/inventory:/ansible/inventory \
                                    -v \$(pwd)/files/ansible/ansible.cfg:/etc/ansible/ansible.cfg \
                                    -e PODMAN_* -e ACTION_TOKEN_*",
                                command: 'ansible-playbook -i inventory/${PODMAN_ANSIBLE_INVENTORY_PATH} \
                                    app/playbooks/playbook.yaml -e "proxy_env=${ENV_SHORT}"')
                            podman.logout()
                            intention.endAction("login")
                            println intention.close(true)
                            intention = null
                        } catch (IllegalStateException ex) {
                            echo "IllegalStateException occurred: $ex"
                            currentBuild.result = 'FAILURE'
                            error('Quitting')
                        } catch (IllegalArgumentException ex) {
                            echo "IllegalArgumentException occurred: $ex"
                            currentBuild.result = 'FAILURE'
                            error('Quitting')
                        } catch (Exception ex) {
                            echo "Other exception occurred: $ex"
                            currentBuild.result = 'FAILURE'
                            error('Quitting')
                        }
                    }
                }
            }
        }
    }
    post {
        unstable {
            script {
                if (intention) {
                    println intention.close(false)
                }
            }
        }
        failure {
            script {
                if (intention) {
                    println intention.close(false)
                }
            }
        }
        aborted {
            script {
                if (intention) {
                    println  intention.close(false)
                }
            }
        }
        always {
            cleanWs(
                cleanWhenAborted: true,
                cleanWhenFailure: false,
                cleanWhenSuccess: true,
                cleanWhenUnstable: false,
                deleteDirs: true,
                patterns: [
                    [pattern: "${appBaseDir}/*", type: 'INCLUDE']
                ]
            )
        }
    }
}
