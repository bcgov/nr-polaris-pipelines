@Library('polaris@feat/stages')
import ca.bc.gov.nrids.polaris.BrokerIntention
import ca.bc.gov.nrids.polaris.JenkinsPipeline
import ca.bc.gov.nrids.polaris.JenkinsUtil
import ca.bc.gov.nrids.polaris.Podman
import ca.bc.gov.nrids.polaris.Vault

def intention
def podman
def jp = new JenkinsPipeline(this)

// Params
// params.gitRepo
// params.gitBasicAuth
// params.gitTag
// params.brokerJwt
// params.user
// params.service
// params.environment
// params.controlAction


pipeline {
    agent {
        label Podman.AGENT_LABEL_APP
    }

    stages {
        stage('Initialize') {
            steps {
                script {
                    // Set the build display name
                    currentBuild.displayName = "#${BUILD_NUMBER} - ${params.environment ?: 'unknown-env'}: ${params.controlAction ?: 'no-action'}"
                    cleanWs()
                }
            }
        }
        stage('Banner') {
            steps {
                echo """
                =====================================================
                            NR Polaris Pipeline
                =====================================================

                Job:    ${env.JOB_NAME}
                Build:  #${env.BUILD_NUMBER}
                URL:    ${env.BUILD_URL}

                Service control pipeline

                Jenkinsfile:
                https://github.com/bcgov-nr/polaris-pipelines/blob/main/pipelines/service-control/Jenkinsfile

                Ansible Polaris collection:
                https://github.com/bcgov/nr-polaris-collection

                Developers are expected to review the documentation
                of all roles used by their Ansible playbook file.
                =====================================================
                """
            }
        }
        stage('Checkout app - new') {
            steps {
                script {
                    def catalogs = jp.retrieveRepoCatalogs(params.gitRepo, params.gitBasicAuth, params.gitTag);
                    echo catalogs
                }
            }
        }
        stage('Retrieve inventory') {
            steps {
                script {
                    jp.retrieveInventory()
                }
            }
        }
        // stage('Checkout app') {
        //     environment {
        //         GIT_REPO = "${params.gitRepo}"
        //         GIT_BRANCH = "${params.configBranch != null && params.configBranch != "" ? params.configBranch : params.gitTag != null && params.gitTag != "" ? params.gitTag : params.gitBranch}"
        //         GITHUB_PRIVATE_REPO = "${params.githubToken ? 'true' : ''}"
        //         SOURCE_ROOT = "${params.sourceRoot && params.sourceRoot != 'null' ? params.sourceRoot : '.'}"
        //         PLAYBOOKS_PATH = "${params.playbooksPath ?: 'playbooks'}"
        //     }
        //     steps {
        //         script {
        //             echo 'NR POLARIS - Checkout app'
        //             echo "GIT_BRANCH: ${GIT_BRANCH}"
        //             sh 'rm -rf app'

        //             // --- Git checkout ---
        //             if (env.GITHUB_PRIVATE_REPO) {
        //                 env.GITHUB_USER  = "${params.githubUser}"
        //                 env.GITHUB_TOKEN = "${params.githubToken}"
        //                 wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [[var: 'GITHUB_TOKEN', password: env.GITHUB_TOKEN]]]) {
        //                     sh """
        //                         git config --global advice.detachedHead false
        //                         git clone -q --no-checkout https://${GITHUB_USER}:${GITHUB_TOKEN}@${GIT_REPO} app
        //                         cd app
        //                         git sparse-checkout set .jenkins catalog-info.yaml
        //                         git checkout ${GIT_BRANCH}
        //                     """
        //                 }
        //             } else {
        //                 sh """
        //                     git config --global advice.detachedHead false
        //                     git clone -q --no-checkout https://${GIT_REPO} app
        //                     cd app
        //                     git sparse-checkout set .jenkins catalog-info.yaml ${SOURCE_ROOT}/${PLAYBOOKS_PATH}
        //                     git checkout ${GIT_BRANCH}
        //                 """
        //             }

        //             // --- Backstage validation ---
        //             dir('app') {
        //                 def catalog = readYaml(file: 'catalog-info.yaml')

        //                 if (catalog.kind == 'Location') {
        //                     echo "catalog-info.yaml is a Location file. Following targets..."

        //                     def matched = false
        //                     catalog.spec.targets.each { target ->
        //                         echo "Checking target: ${target}"
        //                         def child = readYaml(file: target)
        //                         if (child?.metadata?.name == params.appName) {
        //                             echo "Found matching Backstage entity: ${child.metadata.name}"
        //                             matched = true
        //                         }
        //                     }

        //                     if (!matched) {
        //                         error "No Backstage entity found with metadata.name = ${params.appName}"
        //                     }
        //                 } else {
        //                     echo "catalog-info.yaml is not a Location file. Checking directly..."
        //                     if (catalog?.metadata?.name != params.appName) {
        //                         error "catalog-info.yaml metadata.name '${catalog.metadata?.name}' does not match '${params.appName}'"
        //                     }
        //                 }
        //             }
        //         }
        //     }
        // }

        stage('Checkout app') {
            environment {
                GIT_REPO = "${params.gitRepo}"
                GIT_BRANCH = "${params.configBranch != null && params.configBranch != "" ? params.configBranch : params.gitTag != null && params.gitTag != "" ? params.gitTag : params.gitBranch}"
                GITHUB_PRIVATE_REPO = "${params.githubToken != null && params.githubToken != "" ? 'true' : ''}"
                SOURCE_ROOT = "${params.sourceRoot != null && params.sourceRoot != "null" && params.sourceRoot != "" ? params.sourceRoot : "."}"
                PLAYBOOKS_PATH = "${params.playbooksPath != null && params.playbooksPath != "" ? params.playbooksPath : "playbooks"}"
            }
            steps {
                script {
                    echo 'NR POLARIS - Checkout app'
                    echo "GIT_BRANCH: ${GIT_BRANCH}"
                    sh 'rm -rf app'
                    if (env.GITHUB_PRIVATE_REPO) {
                        env.GITHUB_USER = "${params.githubUser}"
                        env.GITHUB_TOKEN = "${params.githubToken}"
                        wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [[var: env.GITHUB_TOKEN, password: GITHUB_TOKEN]]]) {
                            sh '''
                                git config --global advice.detachedHead false
                                git clone -q --no-checkout https://${GITHUB_USER}:${GITHUB_TOKEN}@${GIT_REPO} app
                                cd app
                                git sparse-checkout set .jenkins catalog-info.yaml ${SOURCE_ROOT}/${PLAYBOOKS_PATH}
                                git checkout ${GIT_BRANCH}
                            '''
                        }
                    } else {
                        sh '''
                            git config --global advice.detachedHead false
                            git clone -q --no-checkout https://${GIT_REPO} app
                            cd app
                            git sparse-checkout set .jenkins catalog-info.yaml ${SOURCE_ROOT}/${PLAYBOOKS_PATH}
                            git checkout ${GIT_BRANCH}
                        '''
                    }
                }
            }
        }
        // stage('Run service control') {
        //     environment {
        //         GIT_REPO = "${params.gitRepo}"
        //         GIT_BRANCH = "${params.gitBranch}"
        //         ENV_LONG = "${params.envLong}"
        //         EVENT_PROVIDER = "${params.eventProvider}"
        //         GITHUB_RUNID= "${params.githubRunId}"
        //         TRIGGER_URL = "${params.triggerUrl}"
        //         HTTP_PROXY = "${params.envLong == 'production' ? 'http://forwardproxy.nrs.bcgov:23128' : 'http://test-forwardproxy.nrs.bcgov:23128'}"
        //         ANSIBLE_COLLECTION_VERSION = "${params.ansibleCollectionBranchTag != null && params.ansibleCollectionBranchTag != "" ? ",${params.ansibleCollectionBranchTag}" : ",v3.5.0"}"
        //         PODMAN_ANSIBLE_COLLECTION_URL = "github.com/bcgov/nr-polaris-collection.git#polaris/deploy${env.ANSIBLE_COLLECTION_VERSION}"
        //         PODMAN_ANSIBLE_COLLECTION_PATH = "./collections/ansible_collections"
        //         GIT_CREDS = credentials('ci-user')
        //         GIT_CREDS_USR = GIT_CREDS_USR.replaceFirst('@', '%40')
        //         CONFIG_ROLE_ID = credentials('knox-jenkins-jenkins-apps-prod-role-id')
        //         AUTHFILE = "auth.json"
        //         DEPLOYMENT_APPROVER = "${params.deploymentApprover != null && params.deploymentApprover != "" ? params.deploymentApprover : "github@internal"}"
        //         INTENTION_ID = "${params.intentionId}"
        //         PODMAN_SOURCE_ROOT = "${params.sourceRoot != null && params.sourceRoot != "" ? params.sourceRoot : "."}"
        //         PODMAN_PLAYBOOKS_PATH = "${params.playbooksPath != null && params.playbooksPath != "" ? params.playbooksPath : "playbooks"}"
        //         PODMAN_PLAYBOOKS_PATH = "${params.controlAction}"
        //     }
        //     steps {
        //         script {
        //             try {
        //                 def catalogInfo = readYaml file: 'catalog-info.yaml'
        //                 env.COMPONENT = catalogInfo.metadata.name
        //                 echo "Deploy to ${env.ENV_LONG} environment"
        //                 env.ENV_SHORT = JenkinsUtil.convertLongEnvToShort("${params.envLong}")
        //                 def triggerId = "${env.COMPONENT}:svcctrl:${env.GITHUB_RUNID}"
        //                 intention = new BrokerIntention(readJSON(file: "app/.jenkins/${env.COMPONENT}-control-intention.json"))
        //                 if (env.ENV_SHORT == 'dev') {
        //                     env.PODMAN_ANSIBLE_INVENTORY_PATH = params.devInventoryPath
        //                 } else if (env.ENV_SHORT == 'test') {
        //                     env.PODMAN_ANSIBLE_INVENTORY_PATH = params.testInventoryPath
        //                 } else if (env.ENV_SHORT == 'prod') {
        //                     env.PODMAN_ANSIBLE_INVENTORY_PATH = params.prodInventoryPath
        //                 }
        //                 intention.setEventDetails(
        //                     userName: env.DEPLOYMENT_APPROVER,
        //                     url: env.BUILD_URL,
        //                     provider: env.EVENT_PROVIDER,
        //                     triggerId: triggerId,
        //                     triggerUrl: env.TRIGGER_URL,
        //                     environment: env.ENV_LONG,
        //                 )
        //                 def brokerJwt = "${params.brokerJwt}"
        //                 intention.open(brokerJwt)
        //                 intention.startAction("login")
        //                 def vaultToken = intention.provisionToken("login", CONFIG_ROLE_ID)
        //                 def vault = new Vault(vaultToken)
        //                 vault.readToObject("apps/data/prod/jenkins/jenkins-apps/cdua", env)

        //                 intention.startAction("start")
        //                 intention.openResponse.actions.each { key, value ->
        //                     env."ACTION_TOKEN_${key.toUpperCase()}" = "${value.token}"
        //                 }
        //                 podman = new Podman(this)
        //                 def appMountPath = "\$(pwd)/app"
        //                 podman.login(authfile: "${env.AUTHFILE}", options: "-u ${env.REGISTRY_USERNAME} -p ${env.REGISTRY_PASSWORD}")
        //                 podman.run("willhallonline/ansible:2.16-alpine-3.21",
        //                     authfile: "${env.AUTHFILE}",
        //                     options: "-v \$(pwd):/ansible -e PODMAN_*",
        //                     command: '/bin/sh -c "git config --global advice.detachedHead false && ansible-galaxy collection install git+https://${PODMAN_ANSIBLE_COLLECTION_URL} -p ${PODMAN_ANSIBLE_COLLECTION_PATH}"')
        //                 podman.run("willhallonline/ansible:2.16-alpine-3.21",
        //                     authfile: "${env.AUTHFILE}",
        //                     options: "-v \$(pwd)/collections:/ansible/app/playbooks/collections \
        //                         -v ${appMountPath}:/ansible/app \
        //                         -v \$(pwd)/infra/inventory:/ansible/inventory \
        //                         -v \$(pwd)/files/ansible/ansible.cfg:/etc/ansible/ansible.cfg \
        //                         -v \$(pwd)/downloads:/ansible/downloads \
        //                         -e PODMAN_* -e ACTION_TOKEN_* -e COMPONENT*",
        //                     command: 'ansible-playbook -i inventory/${PODMAN_ANSIBLE_INVENTORY_PATH} \
        //                         app/playbooks/playbook.yaml -e "env_vars=${ENV_SHORT}" -e "proxy_env=${ENV_SHORT}"')
        //                 podman.logout(authfile: "${env.AUTHFILE}")
        //                 intention.endAction("start")

        //                 vault.revokeToken()
        //                 intention.endAction("login")
        //                 println intention.close(true)
        //                 intention = null
        //             } catch (IllegalStateException ex) {
        //                 echo "IllegalStateException occurred: $ex"
        //                 currentBuild.result = 'FAILURE'
        //                 error('Quitting')
        //             } catch (IllegalArgumentException ex) {
        //                 echo "IllegalArgumentException occurred: $ex"
        //                 currentBuild.result = 'FAILURE'
        //                 error('Quitting')
        //             } catch (Exception ex) {
        //                 echo "Other exception occurred: $ex"
        //                 currentBuild.result = 'FAILURE'
        //                 error('Quitting')
        //             }
        //         }
        //     }
        // }
    }
    post {
        unstable {
            node(Podman.AGENT_LABEL_APP) {
                script {
                    if (intention) {
                        println intention.close(false)
                    }
                }
            }
        }
        failure {
            node(Podman.AGENT_LABEL_APP) {
                script {
                    if (intention) {
                        println intention.close(false)
                    }
                }
            }
        }
        aborted {
            node(Podman.AGENT_LABEL_APP) {
                script {
                    if (intention) {
                        println  intention.close(false)
                    }
                }
            }
        }
        always {
            node(Podman.AGENT_LABEL_APP) {
                cleanWs(
                    cleanWhenAborted: true,
                    cleanWhenFailure: false,
                    cleanWhenSuccess: true,
                    cleanWhenUnstable: false,
                    deleteDirs: true
                )
            }
        }
    }
}
